Roadmap for Building a Driving Theory Exam Prep Web App (Kosovo)

This roadmap outlines a phased approach to developing a streamlined web application for driving theory exam preparation in Kosovo. The app will be built with Next.js (React framework), Supabase (backend/database and auth), Tailwind CSS (styling), TypeScript, ShadCN UI (pre-built UI components), and TanStack Query (data fetching & caching). The focus is strictly on features that help users pass the exam, avoiding any unnecessary social or gamification elements. The user experience will be clean, fast, and mobile-first, with multilingual support (Albanian, Serbian, English) and offline access via PWA. Each milestone below represents a stage of development, ensuring the app grows in a logical, scalable way without superfluous features.

Guiding Principles: The app’s content and design should be clear, simple, and focused on helping learners acquire the knowledge needed to pass the theory exam
play.google.com
. We will emphasize fast navigation, light/dark mode for comfort, and quick access to practice tests. Every feature should directly contribute to effective exam preparation.

1. Test Delivery System with Category Support

The first milestone is to build the core test-taking system, supporting all major license categories in Kosovo: Category A (motorcycles), B (cars), C1/C (trucks), CE (trucks with trailer), and D (buses). This forms the foundation of the app’s functionality. Key steps in this phase:

Database & Content Structure: Set up database tables in Supabase for driving theory questions. Organize questions by category (A, B, C1, C, CE, D) so each category’s questions are separate. Each category will have at least 10 exam-style mock tests, with a minimum of 5 questions per test as required. (In practice, real theory exams may have more questions; we ensure our structure can accommodate that.) For simplicity, we might define Test Sets (1–10) for each category, each containing a fixed set or a random draw of questions from that category.

Question Format: Each question entry should include the question text (in multiple languages), 3–5 multiple-choice answers, the correct answer, and an explanation field (to be used in a later milestone). We’ll also include a reference or image field if needed (e.g., for road signs). The content is stored in Supabase (PostgreSQL) for reliable retrieval. Using Supabase allows centralized content management and easy updates.

Next.js Frontend: Implement pages for selecting category and taking tests. For example: a home screen or menu where the user chooses a category (A, B, C, C1, CE, D). After selecting a category, they can pick one of the 10 mock tests to start. The test-taking page will display one question at a time (with options to navigate Next/Previous or directly jump, if desired). We will use ShadCN UI components to build the interface for questions (radios/checkboxes for answers, buttons, modals). ShadCN’s library provides ready-made, accessible components (buttons, cards, dialogs, etc.) that we can easily style with Tailwind CSS. An advantage of ShadCN UI is that it generates code we control (no heavy dependencies or hidden logic)
ui.shadcn.com
, ensuring the UI is lightweight and customizable – perfect for a fast, focused user experience.

Clean & Fast UX: Design a minimal layout emphasizing the question content. Include a sticky header or progress bar showing the current question number out of total. Keep navigation intuitive – for example, a prominent “Next Question” button and maybe keyboard support for answer selection. Implement a light/dark mode toggle early using Tailwind’s dark mode classes or ShadCN’s theming utilities. This toggle can be placed in the header for easy access. The UI should be responsive (Tailwind helps with mobile-first utility classes), ensuring it works well on smartphones since many users will practice on mobile.

Test Submission & Scoring: Allow the user to submit the test when finished (or auto-submit when they reach the end). Immediately calculate the score (% correct) for that attempt. At this stage, we will display the score and which questions were answered correctly or incorrectly. This basic test review view sets the stage for a more robust review system in later milestones. We focus on accuracy and clarity – the user should instantly see if they passed the mock test or not.

Performance considerations: Next.js will handle route-based code splitting to keep initial loads fast. TanStack Query (React Query) will be introduced to fetch question data from Supabase efficiently. By caching queries, repeat visits to a test or question list will load instantly from memory. This will make navigation feel snappy as users move between categories and tests. TanStack Query’s caching and background fetching ensure the app stays fast and updated without manual page refreshes
makerkit.dev
makerkit.dev
.

Multilingual Setup: Begin implementing internationalization. Next.js supports i18n routing, so we can configure locales for sq (Albanian), sr (Serbian), en (English)
nextjs.org
. The UI text (buttons, labels, messages) will be internationalized using a library or Next.js built-in i18n. For content, each question in the database can have translations. Initially, we might focus on one language (say Albanian) for testing, but structure everything to easily add the other languages. For example, a question table might have fields for each language or a related translation table. This way, the user can switch language and the app loads the question content in that language.

By the end of Milestone 1, we will have a working quiz system: users can choose a license category, take a mock exam, and see their score. The app will have a clean, minimal UI with dark mode, and will be fully responsive. We avoid any complex features beyond taking tests. This addresses the primary goal of providing practice exams focused on passing the theory test – no distractions, just Q&A
play.google.com
.

2. User Progress Tracking and Test Review History

Once the basic test-taking functionality is in place, the next step is to introduce user accounts and progress tracking. This milestone ensures that learners can monitor their improvement over time and review past tests – features that are proven to help in exam prep (for example, successful driving test apps track progress and let users review mistakes
totallydriving.com
). Key objectives in this phase:

User Authentication: Integrate Supabase Auth to handle user sign-ups and logins. We can allow email/password or social logins; however, simplicity is key, so even just email (or phone number) login is fine. Supabase provides easy auth setup with secure password handling. Require login for saving progress, but also allow a “guest mode” to try a quick test without sign-up (guest users won’t have saved history).

Progress Storage: Define tables in Supabase for tracking progress, e.g., a test_attempts table that records: user ID, category, test ID, score, date taken, and possibly the answers or questions missed. Enable Row Level Security so users only access their own records. After a user finishes a test, create a new entry with their results.

Progress Dashboard: Create a user dashboard or profile page that shows their overall progress. This should include:

A summary of tests taken per category (e.g., “Category B: 6/10 mock tests completed, best score 90%”).

Perhaps a visual progress indicator or chart of recent scores over time.

An overall “readiness” indicator could be derived from their scores (optional).
The goal is to motivate effective study by showing improvement. As noted in reviews of top apps, the ability to monitor and track progress over time is a highly valued feature
totallydriving.com
. Our app’s progress monitor will give users insight into their preparation journey.

Test Review History: Implement a feature for users to review past tests in detail. On the dashboard, list recent test attempts; clicking one shows the question-by-question breakdown of that attempt. For each question in a past test, display the question, the user’s answer, the correct answer, and (once Milestone 3 is done) the explanation. This “review mode” helps users learn from mistakes. It’s essentially a read-only view of the test after it was submitted. According to driving test app reviews, being able to review questions you got wrong with explanations greatly improves understanding
totallydriving.com
. We’ll emulate this by clearly highlighting incorrect answers and reminding the user of the correct answer with rationale.

UX for Reviews: When a user finishes a test now, in addition to showing score, we provide a “Review Answers” option. If tapped immediately, it goes through each question marking correct/incorrect and showing explanations (if configured to show at end). This immediate review is part of the test flow. Additionally, users can access the same review later via their history. We need to store the necessary data (at least which questions were in that test and the user’s answers) to reconstruct this view.

Fast Navigation & State Management: Use TanStack Query or a state management solution to cache test results and user data. For example, when a test is submitted, update the cached list of attempts for the user so the dashboard updates instantly. Ensure that navigation between the test screen and dashboard is smooth, possibly using Next.js dynamic routes or the App Router for modals. The app should feel snappy when switching views, maintaining that streamlined experience.

Privacy & Security: At this stage, we introduce personal data (user accounts, results). Ensure all communication with Supabase is over SSL (by default) and that sensitive info (like any personal details) are minimal – likely just email and performance data. We adhere to data protection best practices (e.g., provide a way to delete account or data if needed, as noted by similar apps focusing on data safety
play.google.com
). Supabase’s security features (RLS policies, etc.) will guard user data from others.

By the end of Milestone 2, each user will have a personalized experience: login, ability to track their progress, and a history of tests they can review anytime. This encourages deliberate practice, as users can identify which areas or categories need more work. The app remains focused – we are not adding social feeds or leaderboards, but these progress metrics are directly useful for exam success. (Notably, advanced features in other apps like “go over your weaker areas” and “progress monitor” are essentially what we achieve with history and tracking
blog.ingenie.com
.)

3. Explanation Content and Reference Material

With the testing system and progress tracking in place, the next milestone is enriching the learning value of the app by adding explanations for each question and providing reference materials for deeper study. This turns the app from a pure testing tool into a teaching tool as well, which is crucial for helping users truly understand the material (not just memorize answers). Key components of this phase:

Explanations for Questions: Populate the database with an explanation for each question (in all supported languages). The explanation should clarify why the correct answer is right (and optionally why the wrong choices are wrong) – essentially teaching the underlying rule or concept. Many top apps include detailed explanations for both correct and incorrect answers to improve understanding
totallydriving.com
. For example, if a question is about right-of-way at an intersection, the explanation might reference the traffic law that dictates the rule. We will ensure each question’s explanation is concise yet informative, possibly including a reference to the official driving manual or law article. Supabase can store these explanations as text, and we might allow basic formatting (markdown or HTML) for clarity (e.g., bullet lists or emphasis in explanations).

Explanation Display Options: Implement the UX for showing explanations. We have two scenarios:

Practice Mode: Show explanation immediately after the user answers each question. For instance, once the user selects an answer, we instantly reveal if it was correct and display the explanation. This mode is good for learning, not just assessment.

Exam Simulation Mode: Only show explanations after finishing the whole test (or not at all, if the user just wants a score). This simulates a real exam where you only get feedback at the end.
We can allow the user to choose the mode at start or toggle a setting (e.g., a “Show explanation after each question” switch). By default, we might use exam mode to encourage thinking through the whole test, but having the immediate feedback option is useful for study sessions.

UI for Explanations: Ensure the explanation is presented clearly. For practice mode, perhaps show a small toast or expandable panel under the selected answer with the explanation text before moving on. For the end-of-test review, incorporate the explanation under each question’s result. Use ShadCN UI components like accordions or modals if needed to keep the interface tidy (e.g., tap “View Explanation” to expand). The design should keep the user focused on learning – e.g., use a different color or icon to denote an explanation section. The goal is to make it easy for the user to absorb the reasoning behind answers, reinforcing the knowledge needed to pass. As noted, each answer having a detailed explanation enhances understanding
totallydriving.com
.

Reference Material Section: In addition to per-question explanations, provide a section in the app for general study resources:

Driving Handbook / Laws: We can include a summarized version of the Kosovo driving theory handbook or link to it (if available publicly). This might be broken into chapters (road signs, speed limits, right-of-way rules, etc.). Users can read up on topics in-app. If available, integrating official text (Albanian and Serbian versions of the traffic law or driver’s manual) is ideal. Alternatively, we create concise notes for each topic.

Road Sign Gallery: A gallery of road signs with meanings, since recognizing signs is often a big part of theory exams. This could just be static content or flashcards.

FAQs or Tips: Perhaps a list of “most commonly confused rules” or “top tips to pass the theory exam,” gleaned from driving instructors or official guidance.
Including such reference content aligns with features of official apps which often have the full Highway Code or study guides built-in
blog.ingenie.com
. We will keep this reference section easily accessible (maybe a tab or menu section outside of the test flow) but separate from the tests so as not to clutter the test UI.

Integration with Questions: Link the reference material to questions where relevant. For example, if a question is about a road sign, the explanation can include an image of the sign or a link to the road sign reference page. If a question refers to a law (like speed limits), the explanation might cite the chapter in the handbook. This cross-linking helps users dig deeper into any topic they struggle with. It effectively turns mistakes into learning opportunities.

Multilingual Content: Ensure that explanations and references are available in all three languages. This might mean significant content creation effort (translating explanations, etc.), but it’s vital for inclusivity in Kosovo’s context. Supabase could store language-specific fields for explanations, or we could use separate tables keyed by language. We will also provide a language switcher on reference pages. For the UI labels and navigation, our i18n setup from earlier will cover those.

By the end of Milestone 3, the app not only tests users but teaches them. Users can get immediate feedback on every question or review detailed explanations after a test. The presence of official explanations and study guides means the app serves as a one-stop study tool
blog.ingenie.com
 – practice and theory in one. This milestone greatly increases the app’s value by focusing on understanding, which is essential to confidently pass the exam.

4. Admin Panel for Managing Test Content

To keep the app content accurate, up-to-date, and expandable, we need an internal Admin Panel for managing questions, answers, and other content. This milestone is about building tools for content creators or administrators (likely driving instructors or the app maintainers) to easily create and update the test material without direct database edits. While this doesn’t face end-users, it’s critical for long-term scalability and quality. Key features of the admin panel:

Admin Authentication & Authorization: Leverage Supabase’s user roles or a simple approach like an is_admin flag on the user profile. Only authorized admin accounts can access this panel. Implement route protection in Next.js (for example, using middleware or server-side checks) to prevent non-admins from reaching admin pages. Security is paramount here, since the content integrity affects all users.

Questions Management: Provide a CRUD interface to add new questions or edit existing ones. This includes:

Selecting the category (A, B, C1, C, CE, D) for the question.

Inputting the question text in multiple languages (forms for Albanian, Serbian, English).

Inputting answer choices (and marking which one is correct) – perhaps with a dynamic form that can add 3-5 options.

Entering the explanation text (multilingual) and any reference link or image.

Tagging the question with a topic (optional, e.g., “Traffic Signs” or “Speed Limits”) – could be useful for future analytics or filtering, though not strictly needed if we keep it simple.
The form can be built using ShadCN UI form components and React Hook Form for validation. ShadCN UI is well-suited for admin dashboards; in fact, there are open-source admin templates built with it that we can draw inspiration from
github.com
. This ensures the admin UI is as clean as the user UI.

Test (Exam) Management: Because we have 10 predefined tests per category (if we choose to have static sets), the admin panel should allow defining those test sets. For example, an interface to compose Test 1 for Category B by selecting 5+ questions from the B question bank. Alternatively, if tests are generated randomly, we might not need to define sets manually, but having the ability to create a fixed test paper can be useful (especially if we want to ensure coverage of different topics per test). We’ll decide on one approach:

Fixed Tests: Admin picks questions for each of 10 tests per category.

Dynamic: Admin just maintains a question pool per category, and the app randomly draws for each attempt (ensuring no repeats within a test, etc.). In this case, admin panel just manages the pool; no test definitions needed.
Either way, admin should be able to mark certain questions as active/inactive (to retire outdated ones or add new ones).

Reference Content Management: Provide an interface to edit the reference material (e.g., uploading a new PDF of the driving manual, or editing the text of a study guide page). This might include a simple rich-text editor for topics or the ability to reorder sections. If that’s too complex, at least allow updating links or uploading files via Supabase Storage (which can be integrated for things like images or PDFs).

Multilingual Content Support: The admin panel must facilitate entering translations side-by-side to avoid neglecting any language. For example, when adding a new question, admin can input all languages before saving. This ensures consistency (and that one language isn’t missing questions present in another). Possibly incorporate a toggle or tabs for languages in the form.

Testing & Preview: It’s useful if admins can preview how a question will appear to users. We might include a “Preview Question” button that renders the question component with the entered data (using the same front-end components). This way admins see exactly what end-users would see, catching any formatting issues.

Admin Panel Tech: Use Next.js pages or the App Router with a separate layout for admin. We can reuse our component library (ShadCN) for a cohesive look. A simple sidebar for navigation (e.g., “Questions”, “Tests”, “Resources”, “Users”) can be added if multiple tools. Initially focus on questions/tests. We can also use a ready-made admin template or component collection for speed
github.com
github.com
. Supabase also provides a web interface for the database; however, a custom admin panel is friendlier and can include validations (ensuring no two correct answers, etc.).

User Management (optional in admin): Supabase handles auth, but an admin view of users (especially instructors vs normal users) might be handy. At least, allow an admin to elevate a user to instructor role (for Milestone 6) or to disable a user if needed. This can be a simple table of users with roles.

By completing Milestone 4, we empower the content team to keep the app’s question bank accurate and comprehensive. The admin panel ensures the app can evolve (for example, if new regulation questions are added by Kosovo authorities, admins can input those immediately). This helps maintain the app’s relevance and usefulness over time. Crucially, we’re still avoiding extraneous features – the admin panel is strictly for content management, not a general forum or social admin. It will keep the focus on delivering quality exam content.

5. Offline Mode and Progressive Web App (PWA) Features

To make the app accessible anywhere (even with poor or no internet connection), we will implement offline capabilities and PWA enhancements. Kosovo users might not always have stable internet, so offline access can be a big advantage (the competing app highlights features like loading content on weak internet and alerting when offline
play.google.com
). This milestone will make the app function as a Progressive Web App: installable on devices, capable of offline use, and fast like a native app.

PWA Setup: Configure the Next.js app as a PWA by adding a Web App Manifest (with app name, icons, theme colors) and a Service Worker for offline caching. We can use existing solutions like the next-pwa plugin or the newer Serwist library (a Workbox fork)
dev.to
dev.to
. The PWA will allow users to “Install” the web app to their home screen on mobile or as a desktop app. This gives a native-like experience. Benefits of PWA include working offline, background content sync, and improved speed
dev.to
.

Offline Caching Strategy: Decide what to cache for offline use:

Static assets: All the JS, CSS, and image assets will be cached by the Service Worker on first load, so the app shell (UI chrome) works offline.

Question Data: We want users to be able to take tests offline. There are two approaches:

Pre-cache all questions: On initial use (or when the user explicitly triggers “Download questions for offline”), fetch all question data for all categories and store it (possibly in IndexedDB or the Service Worker cache). Given the question bank size (could be a few hundred questions per category), this might be a few thousand questions total – which is feasible to store locally. This ensures any test can be taken offline. We must version this cache so updates from admin can refresh when online.

Cache on-the-fly: Only cache questions that the user has encountered. TanStack Query can persist its cache to local storage or IndexedDB. For example, if a user takes 3 tests while online, those questions and results are stored in the React Query cache (persisted). If they go offline, they can still review those tests and possibly retake them if cache retained the data. However, new tests with unseen questions might not be available offline in this approach.
We likely aim for the first approach for completeness: use Supabase APIs or an export to fetch the full set of questions (or at least the 10 tests for the category the user is interested in) and store them locally. This way, a user can intentionally download a category (or all) while they have Wi-Fi, then practice on the go.

TanStack Query Offline Mode: TanStack Query (React Query v4) has built-in support for offline-aware behaviors
tkdodo.eu
 and can work with cached data when no network is present
tkdodo.eu
. We will leverage this by setting networkMode: 'offlineFirst' for queries that fetch question data. This mode tells React Query to serve cached data and avoid network fetches when offline, preventing errors
tkdodo.eu
tkdodo.eu
. We will also use a query cache persister (like localForage or IndexedDB via a library) to save the cache beyond session. Essentially, once the app loads data, it remains available offline. As long as the cache is filled, the app can function without internet
tkdodo.eu
.

Offline Test Experience: When offline, the app should detect it (via navigator.onLine or an event from the Service Worker) and inform the user (e.g., show an “Offline” badge). If the user tries something that requires internet (like logging in if not already logged, or syncing new data), we handle gracefully – e.g., show a message “No connection – using offline data”
play.google.com
. Key flows:

If a user is already logged in (their session token cached by Supabase and not expired), they can continue to use the app offline. If not logged in, we might allow continuing in guest mode and later sync results.

Taking a test offline: We use the cached questions to display and when the user submits, we store the attempt locally (perhaps in IndexedDB or localStorage via React Query mutation cache). When connection is restored, the app syncs that attempt to the server (so it appears in their history on other devices). Supabase may need an online connection to record results, so we might queue the update. If offline usage is a priority, we can also store multiple attempts and sync later.

We will thoroughly test the scenario of no internet: ensure images (if any, like road sign images) are also cached for offline (e.g., include them in the service worker precache or use base64 if small).

Performance and Speed: PWA features will also improve perceived performance. The app will load instantly from local cache (no white screen as resources are cached). Also, being installable means quicker access for users. PWA is known to make web apps fast and capable like native apps
dev.to
. We’ll verify that the Lighthouse PWA criteria are met (e.g., offline support, splash screen).

Optional: Push Notifications: The roadmap doesn’t list this explicitly, but as a PWA we could consider push notifications (e.g., daily practice reminders or new content alerts). Since we are avoiding unnecessary features, we might skip it for now unless there’s user value (like reminding them to practice if they haven’t in a while). We keep it optional.

At the end of Milestone 5, the app will be a full PWA. Users can install it, and it will work offline or with poor connectivity, allowing continuous practice anywhere. This aligns with our focus on practicality and user needs, especially given local conditions. The app remains secure (data encrypted in transit and not shared) and we’ll make sure any sensitive data is not cached improperly. Achieving offline functionality will set our app apart, making it extremely convenient and reliable for learners.

6. (Optional) Instructor Tools for Assigning Tests

As an optional, nice-to-have milestone, we consider adding minimal instructor tools. This feature is only for driving instructors or driving schools who want to use the app to assign practice tests to their students. We deliberately keep this scoped to test assignment and results – avoiding any complex classroom management, forums, or social feeds (which would be beyond our focus). If implemented, these tools can strengthen collaboration with driving schools (as seen with competitor apps in Kosovo that are endorsed by driving schools
play.google.com
). Here’s what we’d include:

Instructor Role: Extend the user system to have an instructor role (perhaps a boolean flag or a separate table mapping instructor accounts). Driving schools or instructors could register and be marked as instructors (either through an admin verification or a invite code system). In the admin panel (from Milestone 4), an admin could flip a user to instructor status.

Student Linking: Provide a way for instructors to connect with their students on the app. The simplest method: generate a unique code or link for the instructor that a student can enter to link accounts. For example, an instructor “JohnDoe” gets code “XYZ123”; the student enters “XYZ123” in a “Join Instructor” section, which then marks that student’s account as one of JohnDoe’s students. (Alternatively, instructors could create accounts for students or accept requests, but that’s more UX complexity. A code system is straightforward.)

Assigning Tests: Once an instructor has some linked students, they can assign tests. The instructor panel (could be a new page under their account) would allow:

Selecting a student (or multiple students, or even “all my students”).

Selecting a category and one of the 10 tests (or a random test, or specific topics if we have that granularity).

Sending the assignment. Optionally, add a due date or note (but to keep it simple, we might skip due dates initially).
On the student’s side, when they log in, they see a notification or a section of “Assigned Tests”. For each assignment, it shows who assigned it and which test to take. The student can click to start the test directly.

Monitoring Results: Instructors should be able to see the results of the tests they assigned. We can extend the progress tracking so that if a test attempt was initiated as an “assignment” it flags it. Then, in the instructor’s view, they can see a list of completed assignments with scores. At minimum:

A page listing each student and their score for each assigned test (or “pending” if not taken yet).

Possibly an alert if a student hasn’t taken an assigned test by a certain time (if due dates used).

Ability to click and review the student’s answers to see where they made mistakes (basically the same review view, but accessible to the instructor for their student’s attempt). This can help the instructor pinpoint what the student needs help with.

Communication of Assignments: We will not build messaging or forums (staying on mandate to avoid social features), but assignment itself is a form of communication. We should ensure the student is aware of it. A simple implementation is a notification badge in the UI or an email. If PWA push notifications are available (and user enabled them), we could send a push saying “Your instructor assigned you a new test in Category B.” Alternatively, an email through Supabase (it can trigger emails via functions) could notify them. However, even without notifications, as long as the app clearly shows “Assigned Tests: X pending” on the dashboard, that might suffice.

Minimal UI & Effort: Keep the instructor interface very straightforward. Perhaps under the user menu, if the account is instructor, show “Instructor Panel” which has two tabs: “Students” (with invite code and list of linked students) and “Assignments” (with a form to assign and a list of results). Use existing components to list students and assignments in a clean table or list. ShadCN UI can provide tables or list components for a consistent look. We aim for functionality over form here, since it’s an internal tool for instructors.

Privacy & Permissions: Ensure that instructors can only see data for students who have explicitly linked with them (consented). Students should also be able to unlink an instructor if needed (maybe they finished their course or switch instructors). We might include a “Leave instructor” option on the student’s side. Data-wise, a student’s test results would be shared with their linked instructor (again, only those attempts that were assigned or perhaps all attempts if we choose to share overall progress – but default to only assigned test results to respect privacy). We’ll communicate clearly to users if this feature exists so they know an instructor can see their performance on assigned tests.

This instructor tool is optional and should only be built after confirming there is demand (e.g., interest from driving schools to use the app as part of their teaching). If implemented, it can bolster the app’s adoption by making it a complementary tool in driving courses. In Kosovo, an app that works closely with driving schools is seen as a strong point
play.google.com
, and our simple instructor dashboard would support that relationship without straying into unnecessary social features. The instructors get a way to ensure students are practicing, and students get more accountability. All of this remains aligned with the goal of improving exam pass rates, rather than adding fluff.

Conclusion: This roadmap delivers a comprehensive yet focused driving theory prep app through incremental milestones. At each step, we prioritized useful, exam-centric features and avoided scope creep. The final product will allow users to practice mock tests by category, track their progress, learn from explanations, and even study reference materials – all in a slick, responsive interface. It will be fast (thanks to Next.js optimization and caching), secure (Supabase backend with proper auth), and accessible offline (PWA). By structuring development into these phases, we ensure a scalable design where each layer builds on the previous one. Unnecessary features like social feeds, public forums, or excessive gamification were deliberately left out in favor of a lean approach that centers on what helps users pass their driving theory exam. This roadmap provides a clear path to delivering a powerful and streamlined app for Kosovo’s learner drivers.

Sources:

Kosovo-focused driving theory app Autoshkollaime emphasizes clear, simple content structured to help candidates prepare effectively for the exam
play.google.com
, and it’s considered an essential tool for both candidates and instructors in professional preparation
play.google.com
. These principles guided our focus on essential features and optional instructor support.

Reviews of top UK theory test apps highlight features like progress tracking and detailed explanations for answers as key to first-time success
totallydriving.com
totallydriving.com
. Our roadmap includes robust progress monitoring and explanatory content to mirror these proven strategies.

Official DVSA Theory Test Kit and other leading apps bundle practice questions with study materials (Highway Code, guides) and provide progress monitors and official explanations
blog.ingenie.com
. We likewise integrate reference material and knowledge reinforcement in our app.

ShadCN UI was chosen for UI development because it provides pre-built, accessible components without locking you into abstractions – essentially you get clean, maintainable React/TypeScript code as if you wrote it yourself
ui.shadcn.com
. This accelerates development of both user-facing pages and internal admin tools (with community templates available for admin dashboards)
github.com
.

Converting the Next.js app into a PWA yields significant benefits: the app can work offline, load faster, and be installed like a native app
dev.to
. We plan to utilize service worker tools (e.g., Serwist or Workbox) to cache content and enable offline test-taking. React Query’s caching will allow the app to function even without network by serving stored data, as long as the relevant data was fetched beforehand